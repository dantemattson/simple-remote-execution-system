# simple-remote-execution-system
## Year 2 - Systems and Distributed Computing

1. Using a socket connection, the client program will query the remote server program that is listening on port 80.
2. The IP address of the server to be queried by the client shall be given to the client as a command line argument.
3. The client shall wait for the user to enter queries (via stdin), which it then forwards to the server in a loop until the user types ‘quit’. Any responses from the server are immediately displayed to the user.
4. The client will report the time taken for the server to respond to each query together with the server’s response.
5. The client is non-blocking. An infinite number of server queries may be outstanding.
6. The server will spawn a new process to execute each new request and must be able to accept
multiple clients.
7. The server will be able to accept one or more source files and a ‘progname’ and place the files in a directory called ‘progname’. It will be able to compile the source files (if not previously compiled), run the executable with command line arguments provided from the client and return the result to the clients.
8. The source code shall be portable so that it can be compiled and run on both Unix and Windows.
9. The following query commands (and options) are to be recognised by the server (anything within [] is optional):
A. put progname sourcefile[s] [-f] : upload sourcefiles to progname dir, -f overwrite if exists.
B. get progname sourcefile : download sourcefile from progname dir to client screen.
C. run progname [args] [-f localfile] : compile (if req.) and run the executable (with args) and either print the return results to screen or given local file.
D. list [-l] [progname] : list the prognames on the server or files in the given progname directory tothescreen, –l=longlist
E. sys : return the name and version of the Operating System and CPU type.
10. The long list (-l) option of the list command will also return the file size, creation date and access permissions. If no progname is given, then the list of all available progname directories will be returned.
11. The get command will dump the file contents to the screen 40 lines at a time and pause, waiting for a key to be pressed before displaying the next 40 lines etc.
12. The put command will create a new directory on the server called ‘progname’ If the remote progname exists the server will return an error, unless -f has been specified, in which case the directory will be completely overwritten (old content is deleted). This command allows you to upload one or more files from the client to the server
13. If a localfile option is given to the run command a new file on the client will be created. If the localfile name exists the client will return an error, unless -f has been specified in which case the file will be overwritten. If a file with that name already exists the client will return an error before sending the get request to the server.
14. The run command will check to see if a ‘progname’ has been compiled, and if not will compile the relevant files as require. Run will initiate a compile if there is no executable in the folder, or its creation date is older than the last modified date of a source file. It will then run the executable, passing to it any specified command line arguments, and the server will redirect output from the executed program to the client. If the program can’t be run (or compiled) an appropriate error will be returned to the client. You must not use the system() call to compile or run the ‘progname’.
15. If the server receives an incorrectly specified command it will return an error. If the server is unable to execute a valid command the server will return the error string generated by the operating system to the client.
16. All Zombie processes are terminated as required. There is to be no unwanted Zombie processes on either the client, or the server.
